* Things to discuss
** Jin's code
- https://github.com/ying531/MCMC-SymReg
** The hacky implementation of LinearCoefs means that the first =k= samples are not proper
** Error with how I was tracking the variances
- Each sample has one residual variance
- But each tree has their own linear coefficients variances
- For now hacky fix
#+BEGIN_SRC julia :eval :session :results silent :exports code
  i > k ? previous_i = i - k : previous_i = i
  old_σ²_a = chain.samples[previous_i].σ²[:σ²_a]
  old_σ²_b = chain.samples[previous_i].σ²[:σ²_b]
#+END_SRC
** Acceptance ratio calculation
*** Error with transition probabilities
- I had MH reversed in my head
- Numerator transition proposal -> old
- Denominator transition old -> proposal
*** Standard MH
- On Jin's paper they don't use the probability of the LinearCoef
  - I understand not using the probability of jumping between coefficients
    - Because it is symmetric (or in this case just from the prior)
- But why not include the probability of each coefficient?
  
f(\Theta | S)

- They don't use either the probability of the variances (residuals + LinearCoef)
  - I had already included it in the ratio calculation without RJMCMC because I hadn't noticed they omit it 

p(\Sigma)

- Maybe I'm just misunderstanding the equations

** Type stability
#+BEGIN_SRC julia :eval :session :results silent :exports code
  @code_warntype BayesianSR.step(chain, 1, 1, verbose = false)
  # => Body::Union{Float64, BayesianSR.Sample}
#+END_SRC
- Why??
- If I force ~step(...)::Sample~, the warning disappears (as expected)
- No performance differences
- *FIXED:* =NaN= return when ~optimβ!~ failed.
- I believe all the program is type stable now.
** How to select best tree?
- Check change after n steps
** ExprBugs
- There weren't any bugs :D
  - Couldn't reproduce them
  - I misunderstood how mutation, scope, and assigning(=) worked before when I thought there were bugs.
- (apart from the insert! one)
  - https://github.com/sisl/ExprRules.jl/pull/31
* TO-DO
* Notes
